<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Return Feasibility (Client-side)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <style>
    :root {
      color-scheme: light dark;
      font-family: system-ui, -apple-system, Segoe UI, sans-serif;
    }
    body { margin: 1.25rem auto; padding: 0 1rem; max-width: 1100px; }
    h1 { margin-bottom: 0; }
    p.lead { margin-top: 0.25rem; color: #666; }
    section { margin: 1.5rem 0; padding: 1rem; border: 1px solid #ccc; border-radius: 8px; background: rgba(0,0,0,0.02); }
    label { display: block; font-weight: 600; margin-bottom: 0.4rem; }
    input[type="file"] { margin-bottom: 0.8rem; }
    .row { display: grid; gap: 0.75rem; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); align-items: center; }
    .controls { display: flex; gap: 0.75rem; flex-wrap: wrap; align-items: center; }
    button { padding: 0.5rem 1rem; border-radius: 6px; border: 1px solid #888; cursor: pointer; background: #f4f4f4; }
    button.primary { background: #0b6efd; color: white; border-color: #0b6efd; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    select, input[type="number"] { padding: 0.4rem 0.6rem; border-radius: 6px; border: 1px solid #888; }
    table { width: 100%; border-collapse: collapse; margin-top: 1rem; font-size: 0.95rem; }
    th, td { padding: 0.5rem; border: 1px solid #ddd; text-align: left; }
    th { background: rgba(0,0,0,0.05); }
    .status { display: inline-block; padding: 0.2rem 0.55rem; border-radius: 999px; font-weight: 700; color: white; }
    .green { background: #198754; }
    .yellow { background: #ffc107; color: #111; }
    .red { background: #dc3545; }
    .unknown { background: #6c757d; }
    .muted { color: #666; font-size: 0.9rem; }
    .error { color: #dc3545; font-weight: 600; }
    .summary-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 0.75rem; margin: 1rem 0 0.5rem; }
    .summary-card { padding: 0.75rem 0.9rem; border: 1px solid #ccc; border-radius: 8px; background: rgba(0,0,0,0.02); }
    .summary-title { display: flex; align-items: center; gap: 0.5rem; font-weight: 700; }
    .summary-value { font-size: 1.4rem; margin-top: 0.35rem; }
  </style>
</head>
<body>
  <h1>Return Feasibility (No Python required)</h1>
  <p class="lead">Alle Dateien werden im Browser verarbeitet. Keine Installation, keine Admin-Rechte.</p>

  <section>
    <div class="row">
      <div>
        <label for="bookingFile">Booking Return CSV (Airtable)</label>
        <input id="bookingFile" type="file" accept=".csv" />
        <div class="muted">Erwartete Spalten: VIN/vehicle_id, station, Booking Return Date.</div>
      </div>
      <div>
        <label for="stationFile">Stations CSV</label>
        <input id="stationFile" type="file" accept=".csv" />
        <div class="muted">Spalten: Station_Master oder Station_Fix, Latitude, Longitude.</div>
      </div>
      <div>
        <label for="gnssFile">GNSS Export (Power BI, CSV oder XLSX)</label>
        <input id="gnssFile" type="file" accept=".xlsx,.csv" />
        <div class="muted">Spalten: VIN, GNSS Latitude, GNSS Longitude.</div>
      </div>
    </div>

    <div class="controls" style="margin-top: 1rem;">
      <div>
        <label for="greenThreshold">Grün bis (km)</label>
        <input id="greenThreshold" type="number" value="200" min="1" max="2000" />
      </div>
      <div>
        <label for="yellowThreshold">Gelb bis (km)</label>
        <input id="yellowThreshold" type="number" value="1000" min="1" max="5000" />
      </div>
      <button id="generateBtn" class="primary">Ampel berechnen</button>
      <button id="downloadBtn" disabled>CSV herunterladen</button>
      <span id="statusMsg" class="muted"></span>
    </div>
  </section>

  <section>
    <h2>Ergebnis</h2>
    <div class="controls" style="margin-bottom: 0.5rem;">
      <label for="statusFilter" style="margin: 0;">Filter</label>
      <select id="statusFilter">
        <option value="all">Alle Status</option>
        <option value="green">Nur grün</option>
        <option value="yellow">Nur gelb</option>
        <option value="red">Nur rot</option>
        <option value="unknown">Keine Positionsdaten</option>
      </select>
    </div>
    <div id="summary" class="summary-grid muted">Noch keine Daten vorhanden.</div>
    <div id="errorBox" class="error" style="display:none"></div>
    <div id="tableHost" class="muted">Bitte Dateien wählen und "Ampel berechnen" klicken.</div>
  </section>

<script>
  const bookingInput = document.getElementById('bookingFile');
  const stationInput = document.getElementById('stationFile');
  const gnssInput = document.getElementById('gnssFile');
  const generateBtn = document.getElementById('generateBtn');
  const downloadBtn = document.getElementById('downloadBtn');
  const statusMsg = document.getElementById('statusMsg');
  const tableHost = document.getElementById('tableHost');
  const errorBox = document.getElementById('errorBox');
  const summary = document.getElementById('summary');
  const statusFilter = document.getElementById('statusFilter');

  let lastReport = [];

  function normalizeKey(key) {
    return key.replace(/\ufeff/g, '').trim().toLowerCase();
  }

  function sheetToJson(workbook) {
    const sheet = workbook.Sheets[workbook.SheetNames[0]];
    const rows = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: '' });
    if (!rows.length) return [];
    const headers = rows[0].map(normalizeKey);
    return rows.slice(1).map((row) => {
      const obj = {};
      headers.forEach((key, idx) => {
        obj[key] = (row[idx] ?? '').toString();
      });
      return obj;
    });
  }

  function parseNumber(value) {
    if (typeof value === 'number') return value;
    if (!value) return NaN;
    const normalized = value.toString().replace(',', '.');
    const parsed = Number.parseFloat(normalized);
    return Number.isFinite(parsed) ? parsed : NaN;
  }

  function haversineKm(lat1, lon1, lat2, lon2) {
    const toRad = (v) => (v * Math.PI) / 180;
    const R = 6371;
    const dLat = toRad(lat2 - lat1);
    const dLon = toRad(lon2 - lon1);
    const a =
      Math.sin(dLat / 2) * Math.sin(dLat / 2) +
      Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
      Math.sin(dLon / 2) * Math.sin(dLon / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  }

  function classify(distance, thresholds) {
    if (distance == null || Number.isNaN(distance)) {
      return { status: 'unknown', label: 'keine Positionsdaten' };
    }
    if (distance <= thresholds.green) return { status: 'green', label: `${distance.toFixed(1)} km` };
    if (distance <= thresholds.yellow) return { status: 'yellow', label: `${distance.toFixed(1)} km` };
    return { status: 'red', label: `${distance.toFixed(1)} km` };
  }

  function renderTable(rows) {
    const filtered = filterRows(rows);
    if (!filtered.length) {
      tableHost.innerHTML = rows.length
        ? '<div class="muted">Keine Einträge für den aktuellen Filter.</div>'
        : '<div class="muted">Keine Daten berechnet.</div>';
      return;
    }
    const html = [`<table><thead><tr><th>Status</th><th>VIN</th><th>Station</th><th>Distanz</th><th>Aktuelle Position</th><th>Rückgabedatum</th></tr></thead><tbody>`];
    filtered.forEach((row) => {
      html.push(`<tr>
        <td><span class="status ${row.status}">${row.status.toUpperCase()}</span></td>
        <td>${row.vin || ''}</td>
        <td>${row.station || ''}</td>
        <td>${row.distanceLabel}</td>
        <td>${row.location || ''}</td>
        <td>${row.returnDate || ''}</td>
      </tr>`);
    });
    html.push('</tbody></table>');
    tableHost.innerHTML = html.join('');
  }

  function renderSummary(rows) {
    if (!rows.length) {
      summary.innerHTML = '<div class="muted">Noch keine Daten vorhanden.</div>';
      return;
    }

    const counts = rows.reduce(
      (acc, row) => {
        acc[row.status] = (acc[row.status] || 0) + 1;
        acc.total += 1;
        return acc;
      },
      { total: 0 }
    );

    const statusOrder = [
      { key: 'green', label: 'grün', className: 'green' },
      { key: 'yellow', label: 'gelb', className: 'yellow' },
      { key: 'red', label: 'rot', className: 'red' },
      { key: 'unknown', label: 'keine Position', className: 'unknown' },
    ];

    const cards = [`<div class="summary-card"><div class="summary-title">Gesamt</div><div class="summary-value">${counts.total}</div></div>`];
    statusOrder.forEach(({ key, label, className }) => {
      const value = counts[key] || 0;
      cards.push(
        `<div class="summary-card"><div class="summary-title"><span class="status ${className}">${label.toUpperCase()}</span></div><div class="summary-value">${value}</div></div>`
      );
    });

    summary.innerHTML = cards.join('');
  }

  function filterRows(rows) {
    if (statusFilter.value === 'all') return rows;
    return rows.filter((row) => row.status === statusFilter.value);
  }

  function downloadCsv(rows) {
    const header = ['status', 'vin', 'station', 'distance_km', 'location_lat', 'location_lon', 'return_date'];
    const lines = [header.join(',')];
    rows.forEach((r) => {
      lines.push([
        r.status,
        r.vin ?? '',
        r.station ?? '',
        r.distanceKm ?? '',
        r.lat ?? '',
        r.lon ?? '',
        r.returnDate ?? '',
      ].join(','));
    });
    const blob = new Blob([lines.join('\n')], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'return_report.csv';
    a.click();
    URL.revokeObjectURL(url);
  }

  function pickStationName(row) {
    return row['station_master'] || row['station_fix'] || row['station'] || '';
  }

  function parseStationRow(row) {
    const lat = parseNumber(row['latitude'] || row['lat']);
    const lon = parseNumber(row['longitude'] || row['lon']);
    const name = pickStationName(row).trim();
    if (!name || Number.isNaN(lat) || Number.isNaN(lon)) return null;
    return { name: name.toLowerCase(), lat, lon };
  }

  function makeStationMap(rows) {
    const map = new Map();
    rows.forEach((row) => {
      const parsed = parseStationRow(row);
      if (parsed) map.set(parsed.name, { lat: parsed.lat, lon: parsed.lon });
    });
    return map;
  }

  function getValue(row, candidates) {
    for (const key of candidates) {
      if (row[key] != null && row[key] !== '') return row[key];
    }
    return '';
  }

  function pickBySubstring(row, substring) {
    const key = Object.keys(row).find((k) => k.includes(substring));
    return key ? row[key] : '';
  }

  function normalizeDate(value) {
    if (value == null || value === '') return '';
    if (typeof value === 'number') {
      const parsed = XLSX.SSF.parse_date_code(value);
      if (parsed) {
        const date = new Date(Date.UTC(parsed.y, parsed.m - 1, parsed.d));
        return date.toISOString().slice(0, 10);
      }
    }
    const asDate = new Date(value);
    if (!Number.isNaN(asDate.getTime())) return asDate.toISOString().slice(0, 10);
    return value.toString();
  }

  function parseGnssRow(row) {
    const vin = (getValue(row, ['vin', 'vehicle_id']) || pickBySubstring(row, 'vin')).toString().trim();
    const lat = parseNumber(
      getValue(row, ['gnss latitude', 'latitude', 'lat']) || pickBySubstring(row, 'latitude')
    );
    const lon = parseNumber(
      getValue(row, ['gnss longitude', 'longitude', 'lon']) || pickBySubstring(row, 'longitude')
    );
    if (!vin || Number.isNaN(lat) || Number.isNaN(lon)) return null;
    return { vin, lat, lon };
  }

  function makeGnssMap(rows) {
    const map = new Map();
    rows.forEach((row) => {
      const parsed = parseGnssRow(row);
      if (parsed) map.set(parsed.vin, parsed);
    });
    return map;
  }

  function readFileAsArrayBuffer(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = (e) => resolve(e.target.result);
      reader.onerror = (err) => reject(err);
      reader.readAsArrayBuffer(file);
    });
  }

  async function parseFile(file) {
    const buffer = await readFileAsArrayBuffer(file);
    const workbook = XLSX.read(buffer, { type: 'array' });
    return sheetToJson(workbook);
  }

  async function generateReport() {
    errorBox.style.display = 'none';
    errorBox.textContent = '';
    tableHost.innerHTML = '<div class="muted">Berechne ...</div>';
    statusMsg.textContent = 'Dateien werden gelesen...';

    try {
      if (!bookingInput.files.length || !stationInput.files.length || !gnssInput.files.length) {
        throw new Error('Bitte alle drei Dateien auswählen.');
      }

      const [bookingRows, stationRows, gnssRows] = await Promise.all([
        parseFile(bookingInput.files[0]),
        parseFile(stationInput.files[0]),
        parseFile(gnssInput.files[0]),
      ]);

      const stationMap = makeStationMap(stationRows);
      const latestGnss = makeGnssMap(gnssRows);
      const thresholds = {
        green: parseNumber(greenThreshold.value),
        yellow: parseNumber(yellowThreshold.value),
      };

      if (Number.isNaN(thresholds.green) || Number.isNaN(thresholds.yellow) || thresholds.green >= thresholds.yellow) {
        throw new Error('Bitte gültige Schwellwerte eingeben (grün < gelb).');
      }

      const results = bookingRows.map((row) => {
        const vin = (getValue(row, ['vehicle_id', 'vin']) || pickBySubstring(row, 'vin')).toString().trim();
        const stationName = (getValue(row, ['station', 'return']) || pickBySubstring(row, 'station')).toString().trim();
        const returnDate = normalizeDate(
          getValue(row, ['booking return date', 'return date', 'date']) || pickBySubstring(row, 'return')
        );
        const station = stationMap.get(stationName.toLowerCase());
        const gnss = latestGnss.get(vin);
        let distance = null;
        if (station && gnss) {
          distance = haversineKm(station.lat, station.lon, gnss.lat, gnss.lon);
        }
        const classification = classify(distance, thresholds);
        return {
          status: classification.status,
          vin,
          station: stationName,
          distanceKm: distance != null && !Number.isNaN(distance) ? distance.toFixed(2) : '',
          distanceLabel: classification.label,
          lat: gnss?.lat ?? '',
          lon: gnss?.lon ?? '',
          location: gnss ? `${gnss.lat.toFixed(5)}, ${gnss.lon.toFixed(5)}` : '–',
          returnDate,
        };
      });

      lastReport = results;
      renderSummary(results);
      renderTable(results);
      downloadBtn.disabled = !results.length;
      statusMsg.textContent = `Fertig: ${results.length} Fahrzeuge ausgewertet.`;
    } catch (err) {
      console.error(err);
      errorBox.textContent = err.message;
      errorBox.style.display = 'block';
      tableHost.innerHTML = '<div class="muted">Fehler beim Verarbeiten.</div>';
      statusMsg.textContent = '';
    }
  }

  generateBtn.addEventListener('click', generateReport);
  downloadBtn.addEventListener('click', () => {
    if (lastReport.length) downloadCsv(lastReport);
  });
  statusFilter.addEventListener('change', () => {
    renderTable(lastReport);
  });
</script>
</body>
</html>
